"""
Build backend implementation for smelt.

@date: 12.06.2025
@author: Baptiste Pestourie
"""

from __future__ import annotations

import importlib
import os
import shutil
import tempfile
import warnings
from contextlib import contextmanager
from dataclasses import asdict, dataclass
from pathlib import Path
from types import ModuleType
from typing import Generator

from mypyc.build import mypycify

from smelt.compiler import compile_extension
from smelt.nuitkaify import Stdout, compile_with_nuitka

# TODO: replace .so references to a variable that's set to .so
# for Unix-like and .dll for Windows


class SmeltError(Exception):
    """
    Base exception class for Smelt errors
    """


class SmeltMissingModule(SmeltError): ...


@contextmanager
def import_shadowed_module(path: str) -> Generator[ModuleType, None, None]:
    """
    Allows importting a .py module shadowed by its .so counterpart
    (typically generated by mypy).
    .so python modules (generally, compiled C extensions) have higher priority on import
    over .py modules. This is is done so that module can provide optional C extensions
    with a pure Python implementation as fallback (e.g., if the interpreter is not CPython,
    or if the C extension cannot be compiled for the target platform)

    This function temporarily REMOVES the .so and proceeds to import the shadowed.
    It is a context manager and will restore the removed .so on exit,
    unless a new version has been built in the meantime (e.g., if the import
    was required as part of a recompile process)
    """
    with tempfile.TemporaryDirectory() as tmp:
        try:
            mod = importlib.import_module(path)
        except ImportError as exc:
            msg = f"Failed to import {path} while trying to mypycify"
            raise SmeltMissingModule(msg) from exc
        mod_path = mod.__file__
        assert mod_path is not None, f"Cannot module to mypycify: {path}"
        if mod_path.endswith((".py", ".pyc")):
            yield mod
        else:
            backup_path = os.path.join(tmp, os.path.basename(mod_path))
            shutil.copy(mod_path, backup_path)
            os.remove(mod_path)
            os.sync()

            try:
                # using reload as otherwise importlib will use the cache
                # and re-import the now deleted .so
                mod = importlib.reload(mod)
                assert mod.__file__ is not None and not (mod.__file__.endswith(".so"))
                yield mod
            except ImportError as exc:
                msg = f"Failed to import {path} while trying to mypycify"
                raise SmeltMissingModule(msg) from exc

            finally:
                # restoring
                shutil.move(backup_path, mod_path)


@dataclass
class SmeltConfig:
    """
    Defines how the smelt backend should run
    """

    mypyc: list[str]
    c_extensions: dict[str, str]
    entrypoint: str

    def __str__(self) -> str:
        """
        A human-friendly stringified version of this config.
        """
        lines: list[str] = []
        for field_name, value in asdict(self).items():
            if isinstance(value, list):
                value = ",".join(value)
            if isinstance(value, dict):
                value = "".join(
                    ("\n * " + f"{key} -> {val}" for key, val in value.items())
                )
            lines.append(f"{field_name:20}: {value}")
        return "\n".join(lines)


def run_backend(
    config: SmeltConfig, stdout: Stdout | None = None, project_root: Path | str = "."
) -> None:
    """
    Runs the whole backend pipeline:
    * C extensions compilation
    * mypyc extensions
    * Nuitka compilation
    """
    # Starting with C extensions
    warnings.warn(
        "`run_backend` implementation is not fully implemented yet and will only "
        "compile C extensions"
    )
    for c_extension, relative_path in config.c_extensions.items():
        c_extension_path = os.path.join(project_root, relative_path)
        parent_folder_path = Path(c_extension_path).parent
        # TODO: we should probably run that logic in temp folder
        built_so_path = compile_extension(c_extension_path)
        so_final_path = parent_folder_path / os.path.basename(built_so_path)
        shutil.move(built_so_path, so_final_path)

    # Note: mypyc has a runtime shipped as a separate extension
    # this runtime should be named modname__mypy
    # we need to keep track of it to include to nuitka,
    # as it would be invisible otherwise
    mypy_runtime_extensions: list[str] = []
    for mypyc_extension in config.mypyc:
        with import_shadowed_module(mypyc_extension) as mod:
            # TODO: seems that mypy detects the package and names the module package.mod
            # automatically ?
            assert mod.__file__ is not None
            extensions = mypycify([mod.__file__], include_runtime_files=True)
            mod_folder = Path(mod.__file__).parent
            for ext in extensions:
                ext_name = ext.name.split(".")[-1]
                is_runtime = "__mypyc" in ext_name
                built_so_path = compile_extension(ext)
                built_so_path.replace(mod.__name__, ext_name)
                # TODO: see above
                so_final_path = mod_folder / os.path.basename(built_so_path).replace(
                    ext.name, ext_name
                )
                shutil.move(built_so_path, so_final_path)
                if is_runtime:
                    mypy_runtime_extensions.append(ext.name)
    # nuitka compile
    entrypoint = config.entrypoint
    try:
        entrypoint_mod = importlib.import_module(entrypoint)
    except ImportError as exc:
        msg = f"Failed to import entrypoint: {entrypoint}"
        raise SmeltMissingModule(msg) from exc
    assert (
        entrypoint_mod.__file__ is not None
    ), f"Failed to locate entrypoint: {entrypoint}"
    compile_with_nuitka(
        entrypoint_mod.__file__, stdout=stdout, include_modules=mypy_runtime_extensions
    )
